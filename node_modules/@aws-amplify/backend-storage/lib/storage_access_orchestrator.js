import { entityIdPathToken, entityIdSubstitution } from './constants.js';
import { validateStorageAccessPaths as _validateStorageAccessPaths } from './validate_storage_access_paths.js';
import { roleAccessBuilder as _roleAccessBuilder } from './access_builder.js';
import { AmplifyUserError } from '@aws-amplify/platform-core';
/**
 * Orchestrates the process of converting customer-defined storage access rules into corresponding IAM policies
 * and attaching those policies to the corresponding IAM roles
 */
export class StorageAccessOrchestrator {
    storageAccessGenerator;
    getInstanceProps;
    ssmEnvironmentEntries;
    policyFactory;
    validateStorageAccessPaths;
    roleAccessBuilder;
    /**
     * Maintains a mapping from a resource access acceptor to all of the access grants it has been configured with
     * Each entry of this map is fed into the policy generator to create a single policy for each acceptor
     */
    acceptorAccessMap = new Map();
    /**
     * Maintains pointers to the "deny" StoragePath Set for each access entry in the map above
     * This map is used during a final pass over all the StoragePaths to deny access on any paths where explicit allow rules were not specified
     */
    prefixDenyMap = new Map();
    /**
     * Instantiate with the access generator and other dependencies necessary for evaluating and constructing access policies
     * @param storageAccessGenerator The access callback defined by the customer
     * @param getInstanceProps props for fetching construct instances from the construct container
     * @param ssmEnvironmentEntries SSM context that should be passed to the ResourceAccessAcceptors when configuring access
     * @param policyFactory factory that generates IAM policies for various access control definitions
     * @param validateStorageAccessPaths validator function for checking access definition paths
     * @param roleAccessBuilder builder instance that is injected into the storageAccessGenerator to evaluate the rules
     */
    constructor(storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory, validateStorageAccessPaths = _validateStorageAccessPaths, roleAccessBuilder = _roleAccessBuilder) {
        this.storageAccessGenerator = storageAccessGenerator;
        this.getInstanceProps = getInstanceProps;
        this.ssmEnvironmentEntries = ssmEnvironmentEntries;
        this.policyFactory = policyFactory;
        this.validateStorageAccessPaths = validateStorageAccessPaths;
        this.roleAccessBuilder = roleAccessBuilder;
    }
    /**
     * Orchestrates the process of translating the customer-provided storage access rules into IAM policies and attaching those policies to the appropriate roles.
     *
     * The high level steps are:
     * 1. Invokes the storageAccessGenerator to produce a storageAccessDefinition
     * 2. Validates the paths in the storageAccessDefinition
     * 3. Organizes the storageAccessDefinition into internally managed maps to facilitate translation into allow / deny rules on IAM policies
     * 4. Invokes the policy generator to produce a policy with appropriate allow / deny rules
     * 5. Invokes the resourceAccessAcceptors for each entry in the storageAccessDefinition to accept the corresponding IAM policy
     */
    orchestrateStorageAccess = () => {
        // storageAccessGenerator is the access callback defined by the customer
        // here we inject the roleAccessBuilder into the callback and run it
        // this produces the access definition that will be used to create the storage policies
        const storageAccessDefinition = this.storageAccessGenerator(this.roleAccessBuilder);
        // verify that the paths in the access definition are valid
        this.validateStorageAccessPaths(Object.keys(storageAccessDefinition));
        const storageOutputAccessDefinition = {};
        // iterate over the access definition and group permissions by ResourceAccessAcceptor
        Object.entries(storageAccessDefinition).forEach(([s3Prefix, accessPermissions]) => {
            const uniqueDefinitionIdSet = new Set();
            // iterate over all of the access definitions for a given prefix
            accessPermissions.forEach((permission) => {
                const accessConfig = {};
                // replace "read" with "get" and "list" in actions
                const replaceReadWithGetAndList = permission.actions.flatMap((action) => (action === 'read' ? ['get', 'list'] : [action]));
                // ensure the actions list has no duplicates
                const noDuplicateActions = Array.from(new Set(replaceReadWithGetAndList));
                // iterate over all uniqueDefinitionIdValidations and ensure uniqueness within this path prefix
                permission.uniqueDefinitionIdValidations.forEach(({ uniqueDefinitionId, validationErrorOptions }) => {
                    if (uniqueDefinitionIdSet.has(uniqueDefinitionId)) {
                        throw new AmplifyUserError('InvalidStorageAccessDefinitionError', validationErrorOptions);
                    }
                    else {
                        uniqueDefinitionIdSet.add(uniqueDefinitionId);
                    }
                    accessConfig[uniqueDefinitionId] = noDuplicateActions;
                });
                // make the owner placeholder substitution in the s3 prefix
                const prefix = placeholderSubstitution(s3Prefix, permission.idSubstitution);
                storageOutputAccessDefinition[prefix] = {
                    ...storageOutputAccessDefinition[prefix],
                    ...accessConfig,
                };
                // set an entry that maps this permission to each resource acceptor
                permission.getResourceAccessAcceptors.forEach((getResourceAccessAcceptor) => {
                    this.addAccessDefinition(getResourceAccessAcceptor(this.getInstanceProps), noDuplicateActions, prefix);
                });
            });
        });
        // iterate over the access map entries and invoke each ResourceAccessAcceptor to accept the permissions
        this.attachPolicies(this.ssmEnvironmentEntries);
        return storageOutputAccessDefinition;
    };
    /**
     * Add an entry to the internal acceptorAccessMap and prefixDenyMap.
     * This entry defines a set of actions on a single s3 prefix that should be attached to a given ResourceAccessAcceptor
     */
    addAccessDefinition = (resourceAccessAcceptor, actions, s3Prefix) => {
        const acceptorToken = resourceAccessAcceptor.identifier;
        // if we haven't seen this token before, add it to the map
        if (!this.acceptorAccessMap.has(acceptorToken)) {
            this.acceptorAccessMap.set(acceptorToken, {
                accessMap: new Map(),
                acceptor: resourceAccessAcceptor,
            });
        }
        const accessMap = this.acceptorAccessMap.get(acceptorToken).accessMap;
        // add each action to the accessMap for this acceptorToken
        actions.forEach((action) => {
            if (!accessMap.has(action)) {
                // if we haven't seen this action for this acceptorToken before, add it to the map
                const allowSet = new Set([s3Prefix]);
                const denySet = new Set();
                accessMap.set(action, { allow: allowSet, deny: denySet });
                // this is where we create the reverse mapping that allows us to add entries to the denySet later by looking up the prefix
                this.setPrefixDenyMapEntry(s3Prefix, allowSet, denySet);
            }
            else {
                // otherwise add the prefix to the existing allow set
                const { allow: allowSet, deny: denySet } = accessMap.get(action);
                allowSet.add(s3Prefix);
                // add an entry in the prefixDenyMap for the existing allow and deny set
                this.setPrefixDenyMapEntry(s3Prefix, allowSet, denySet);
            }
        });
    };
    /**
     * Iterates over all of the access definitions that have been added to the orchestrator,
     * generates a policy for each accessMap,
     * and attaches the policy to the corresponding ResourceAccessAcceptor
     *
     * After this method is called, the existing access definition state is cleared.
     * This prevents multiple calls to this method from producing duplicate policies.
     * The class can continue to be used to build up state for a new set of policies if desired.
     * @param ssmEnvironmentEntries Additional SSM context that is passed to each ResourceAccessAcceptor
     */
    attachPolicies = (ssmEnvironmentEntries) => {
        const allPaths = Array.from(this.prefixDenyMap.keys());
        allPaths.forEach((storagePath) => {
            const parent = findParent(storagePath, allPaths);
            // do not add to prefix deny map if there is no parent or the path is a subpath with entity id
            if (!parent ||
                parent === storagePath.replaceAll(`${entityIdSubstitution}/`, '')) {
                return;
            }
            // if a parent path is defined, invoke the denyByDefault callback on this subpath for all policies that exist on the parent path
            this.prefixDenyMap
                .get(parent)
                ?.forEach((denyByDefaultCallback) => denyByDefaultCallback(storagePath));
        });
        this.acceptorAccessMap.forEach(({ acceptor, accessMap }) => {
            // removing subpaths from the allow set prevents unnecessary paths from being added to the policy
            // for example, if there are allow read rules for /foo/* and /foo/bar/* we only need to add /foo/* to the policy because that includes /foo/bar/*
            accessMap.forEach(({ allow }) => {
                removeSubPathsFromSet(allow);
            });
            acceptor.acceptResourceAccess(this.policyFactory.createPolicy(accessMap), ssmEnvironmentEntries);
        });
        this.acceptorAccessMap.clear();
        this.prefixDenyMap.clear();
    };
    setPrefixDenyMapEntry = (storagePath, allowPathSet, denyPathSet) => {
        // function that will add the denyPath to the denyPathSet unless the allowPathSet explicitly allows the path
        const setDenyByDefault = (denyPath) => {
            if (!allowPathSet.has(denyPath)) {
                denyPathSet.add(denyPath);
            }
        };
        if (!this.prefixDenyMap.has(storagePath)) {
            this.prefixDenyMap.set(storagePath, [setDenyByDefault]);
        }
        else {
            this.prefixDenyMap.get(storagePath)?.push(setDenyByDefault);
        }
    };
}
/**
 * This factory is really only necessary for allowing us to mock the StorageAccessOrchestrator in tests
 */
export class StorageAccessOrchestratorFactory {
    getInstance = (storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory) => new StorageAccessOrchestrator(storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory);
}
/**
 * Performs the owner placeholder substitution in the s3 prefix
 */
const placeholderSubstitution = (s3Prefix, idSubstitution) => {
    const prefix = s3Prefix.replaceAll(entityIdPathToken, idSubstitution);
    // for owner paths where prefix ends with '/*/*' remove the last wildcard
    if (prefix.endsWith('/*/*')) {
        return prefix.slice(0, -2);
    }
    return prefix;
};
/**
 * Returns the element in paths that is a prefix of path, if any
 * Note that there can only be one at this point because of upstream validation
 */
const findParent = (path, paths) => paths.find((p) => path !== p && path.startsWith(p.replaceAll('*', '')));
const removeSubPathsFromSet = (paths) => {
    paths.forEach((path) => {
        if (findParent(path, Array.from(paths))) {
            paths.delete(path);
        }
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZV9hY2Nlc3Nfb3JjaGVzdHJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3N0b3JhZ2VfYWNjZXNzX29yY2hlc3RyYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFVQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV6RSxPQUFPLEVBQUUsMEJBQTBCLElBQUksMkJBQTJCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUMvRyxPQUFPLEVBQUUsaUJBQWlCLElBQUksa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQU05RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQVU5RDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8seUJBQXlCO0lBZ0NqQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFwQ25COzs7T0FHRztJQUNLLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQVNoQyxDQUFDO0lBRUo7OztPQUdHO0lBQ0ssYUFBYSxHQUFHLElBQUksR0FBRyxFQUFtQyxDQUFDO0lBRW5FOzs7Ozs7OztPQVFHO0lBQ0gsWUFDbUIsc0JBQThDLEVBQzlDLGdCQUFrRCxFQUNsRCxxQkFBNEMsRUFDNUMsYUFBeUMsRUFDekMsNkJBQTZCLDJCQUEyQixFQUN4RCxvQkFBMEMsa0JBQWtCO1FBTDVELDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFDOUMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQztRQUNsRCwwQkFBcUIsR0FBckIscUJBQXFCLENBQXVCO1FBQzVDLGtCQUFhLEdBQWIsYUFBYSxDQUE0QjtRQUN6QywrQkFBMEIsR0FBMUIsMEJBQTBCLENBQThCO1FBQ3hELHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBMkM7SUFDNUUsQ0FBQztJQUVKOzs7Ozs7Ozs7T0FTRztJQUNILHdCQUF3QixHQUFHLEdBQUcsRUFBRTtRQUM5Qix3RUFBd0U7UUFD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QyxFQUFFO1FBQzNCLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQWdCLENBQUM7S0FDM0M7SUFFRCxPQUFPLE1BQXFCLENBQUM7QUFDL0IsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLEdBQUcsQ0FBQyxJQUFZLEVBQUUsS0FBZSxFQUFFLEVBQUUsQ0FDbkQsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBRXpELENBQUM7QUFFaEIsTUFBTSxxQkFBcUIsR0FBRyxDQUFDLEtBQXVCLEVBQUUsRUFBRTtJQUN4RCxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDckIsSUFBSSxVQUFVLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUN2QyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BCO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb25zdHJ1Y3RGYWN0b3J5R2V0SW5zdGFuY2VQcm9wcyxcbiAgUmVzb3VyY2VBY2Nlc3NBY2NlcHRvcixcbiAgU3NtRW52aXJvbm1lbnRFbnRyeSxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5pbXBvcnQge1xuICBTdG9yYWdlQWNjZXNzQnVpbGRlcixcbiAgU3RvcmFnZUFjY2Vzc0dlbmVyYXRvcixcbiAgU3RvcmFnZVBhdGgsXG59IGZyb20gJy4vdHlwZXMuanMnO1xuaW1wb3J0IHsgZW50aXR5SWRQYXRoVG9rZW4sIGVudGl0eUlkU3Vic3RpdHV0aW9uIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgU3RvcmFnZUFjY2Vzc1BvbGljeUZhY3RvcnkgfSBmcm9tICcuL3N0b3JhZ2VfYWNjZXNzX3BvbGljeV9mYWN0b3J5LmpzJztcbmltcG9ydCB7IHZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzIGFzIF92YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyB9IGZyb20gJy4vdmFsaWRhdGVfc3RvcmFnZV9hY2Nlc3NfcGF0aHMuanMnO1xuaW1wb3J0IHsgcm9sZUFjY2Vzc0J1aWxkZXIgYXMgX3JvbGVBY2Nlc3NCdWlsZGVyIH0gZnJvbSAnLi9hY2Nlc3NfYnVpbGRlci5qcyc7XG5pbXBvcnQge1xuICBJbnRlcm5hbFN0b3JhZ2VBY3Rpb24sXG4gIFN0b3JhZ2VBY2Nlc3NDb25maWcsXG4gIFN0b3JhZ2VFcnJvcixcbn0gZnJvbSAnLi9wcml2YXRlX3R5cGVzLmpzJztcbmltcG9ydCB7IEFtcGxpZnlVc2VyRXJyb3IgfSBmcm9tICdAYXdzLWFtcGxpZnkvcGxhdGZvcm0tY29yZSc7XG5cbi8qIHNvbWUgdHlwZXMgaW50ZXJuYWwgdG8gdGhpcyBmaWxlIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkgKi9cblxuLy8gQWxpYXMgdHlwZSBmb3IgYSBzdHJpbmcgdGhhdCBpcyBhIFJlc291cmNlQWNjZXNzQWNjZXB0b3IgdG9rZW5cbnR5cGUgQWNjZXB0b3JUb2tlbiA9IHN0cmluZztcblxuLy8gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBwbGFjZXMgc3RvcmFnZVBhdGggaW4gdGhlIGRlbnkgbGlzdCBmb3IgYW4gYWN0aW9uIGlmIGl0IGlzIG5vdCBleHBsaWNpdGx5IGFsbG93ZWQgYnkgYW5vdGhlciBydWxlXG50eXBlIFNldERlbnlCeURlZmF1bHQgPSAoc3RvcmFnZVBhdGg6IFN0b3JhZ2VQYXRoKSA9PiB2b2lkO1xuXG4vKipcbiAqIE9yY2hlc3RyYXRlcyB0aGUgcHJvY2VzcyBvZiBjb252ZXJ0aW5nIGN1c3RvbWVyLWRlZmluZWQgc3RvcmFnZSBhY2Nlc3MgcnVsZXMgaW50byBjb3JyZXNwb25kaW5nIElBTSBwb2xpY2llc1xuICogYW5kIGF0dGFjaGluZyB0aG9zZSBwb2xpY2llcyB0byB0aGUgY29ycmVzcG9uZGluZyBJQU0gcm9sZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0b3JhZ2VBY2Nlc3NPcmNoZXN0cmF0b3Ige1xuICAvKipcbiAgICogTWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcmVzb3VyY2UgYWNjZXNzIGFjY2VwdG9yIHRvIGFsbCBvZiB0aGUgYWNjZXNzIGdyYW50cyBpdCBoYXMgYmVlbiBjb25maWd1cmVkIHdpdGhcbiAgICogRWFjaCBlbnRyeSBvZiB0aGlzIG1hcCBpcyBmZWQgaW50byB0aGUgcG9saWN5IGdlbmVyYXRvciB0byBjcmVhdGUgYSBzaW5nbGUgcG9saWN5IGZvciBlYWNoIGFjY2VwdG9yXG4gICAqL1xuICBwcml2YXRlIGFjY2VwdG9yQWNjZXNzTWFwID0gbmV3IE1hcDxcbiAgICBBY2NlcHRvclRva2VuLFxuICAgIHtcbiAgICAgIGFjY2VwdG9yOiBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yO1xuICAgICAgYWNjZXNzTWFwOiBNYXA8XG4gICAgICAgIEludGVybmFsU3RvcmFnZUFjdGlvbixcbiAgICAgICAgeyBhbGxvdzogU2V0PFN0b3JhZ2VQYXRoPjsgZGVueTogU2V0PFN0b3JhZ2VQYXRoPiB9XG4gICAgICA+O1xuICAgIH1cbiAgPigpO1xuXG4gIC8qKlxuICAgKiBNYWludGFpbnMgcG9pbnRlcnMgdG8gdGhlIFwiZGVueVwiIFN0b3JhZ2VQYXRoIFNldCBmb3IgZWFjaCBhY2Nlc3MgZW50cnkgaW4gdGhlIG1hcCBhYm92ZVxuICAgKiBUaGlzIG1hcCBpcyB1c2VkIGR1cmluZyBhIGZpbmFsIHBhc3Mgb3ZlciBhbGwgdGhlIFN0b3JhZ2VQYXRocyB0byBkZW55IGFjY2VzcyBvbiBhbnkgcGF0aHMgd2hlcmUgZXhwbGljaXQgYWxsb3cgcnVsZXMgd2VyZSBub3Qgc3BlY2lmaWVkXG4gICAqL1xuICBwcml2YXRlIHByZWZpeERlbnlNYXAgPSBuZXcgTWFwPFN0b3JhZ2VQYXRoLCBTZXREZW55QnlEZWZhdWx0W10+KCk7XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIHdpdGggdGhlIGFjY2VzcyBnZW5lcmF0b3IgYW5kIG90aGVyIGRlcGVuZGVuY2llcyBuZWNlc3NhcnkgZm9yIGV2YWx1YXRpbmcgYW5kIGNvbnN0cnVjdGluZyBhY2Nlc3MgcG9saWNpZXNcbiAgICogQHBhcmFtIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IgVGhlIGFjY2VzcyBjYWxsYmFjayBkZWZpbmVkIGJ5IHRoZSBjdXN0b21lclxuICAgKiBAcGFyYW0gZ2V0SW5zdGFuY2VQcm9wcyBwcm9wcyBmb3IgZmV0Y2hpbmcgY29uc3RydWN0IGluc3RhbmNlcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY29udGFpbmVyXG4gICAqIEBwYXJhbSBzc21FbnZpcm9ubWVudEVudHJpZXMgU1NNIGNvbnRleHQgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9ycyB3aGVuIGNvbmZpZ3VyaW5nIGFjY2Vzc1xuICAgKiBAcGFyYW0gcG9saWN5RmFjdG9yeSBmYWN0b3J5IHRoYXQgZ2VuZXJhdGVzIElBTSBwb2xpY2llcyBmb3IgdmFyaW91cyBhY2Nlc3MgY29udHJvbCBkZWZpbml0aW9uc1xuICAgKiBAcGFyYW0gdmFsaWRhdGVTdG9yYWdlQWNjZXNzUGF0aHMgdmFsaWRhdG9yIGZ1bmN0aW9uIGZvciBjaGVja2luZyBhY2Nlc3MgZGVmaW5pdGlvbiBwYXRoc1xuICAgKiBAcGFyYW0gcm9sZUFjY2Vzc0J1aWxkZXIgYnVpbGRlciBpbnN0YW5jZSB0aGF0IGlzIGluamVjdGVkIGludG8gdGhlIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IgdG8gZXZhbHVhdGUgdGhlIHJ1bGVzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3I6IFN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IsXG4gICAgcHJpdmF0ZSByZWFkb25seSBnZXRJbnN0YW5jZVByb3BzOiBDb25zdHJ1Y3RGYWN0b3J5R2V0SW5zdGFuY2VQcm9wcyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNzbUVudmlyb25tZW50RW50cmllczogU3NtRW52aXJvbm1lbnRFbnRyeVtdLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcG9saWN5RmFjdG9yeTogU3RvcmFnZUFjY2Vzc1BvbGljeUZhY3RvcnksXG4gICAgcHJpdmF0ZSByZWFkb25seSB2YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyA9IF92YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJvbGVBY2Nlc3NCdWlsZGVyOiBTdG9yYWdlQWNjZXNzQnVpbGRlciA9IF9yb2xlQWNjZXNzQnVpbGRlcixcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBPcmNoZXN0cmF0ZXMgdGhlIHByb2Nlc3Mgb2YgdHJhbnNsYXRpbmcgdGhlIGN1c3RvbWVyLXByb3ZpZGVkIHN0b3JhZ2UgYWNjZXNzIHJ1bGVzIGludG8gSUFNIHBvbGljaWVzIGFuZCBhdHRhY2hpbmcgdGhvc2UgcG9saWNpZXMgdG8gdGhlIGFwcHJvcHJpYXRlIHJvbGVzLlxuICAgKlxuICAgKiBUaGUgaGlnaCBsZXZlbCBzdGVwcyBhcmU6XG4gICAqIDEuIEludm9rZXMgdGhlIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IgdG8gcHJvZHVjZSBhIHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uXG4gICAqIDIuIFZhbGlkYXRlcyB0aGUgcGF0aHMgaW4gdGhlIHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uXG4gICAqIDMuIE9yZ2FuaXplcyB0aGUgc3RvcmFnZUFjY2Vzc0RlZmluaXRpb24gaW50byBpbnRlcm5hbGx5IG1hbmFnZWQgbWFwcyB0byBmYWNpbGl0YXRlIHRyYW5zbGF0aW9uIGludG8gYWxsb3cgLyBkZW55IHJ1bGVzIG9uIElBTSBwb2xpY2llc1xuICAgKiA0LiBJbnZva2VzIHRoZSBwb2xpY3kgZ2VuZXJhdG9yIHRvIHByb2R1Y2UgYSBwb2xpY3kgd2l0aCBhcHByb3ByaWF0ZSBhbGxvdyAvIGRlbnkgcnVsZXNcbiAgICogNS4gSW52b2tlcyB0aGUgcmVzb3VyY2VBY2Nlc3NBY2NlcHRvcnMgZm9yIGVhY2ggZW50cnkgaW4gdGhlIHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uIHRvIGFjY2VwdCB0aGUgY29ycmVzcG9uZGluZyBJQU0gcG9saWN5XG4gICAqL1xuICBvcmNoZXN0cmF0ZVN0b3JhZ2VBY2Nlc3MgPSAoKSA9PiB7XG4gICAgLy8gc3RvcmFnZUFjY2Vzc0dlbmVyYXRvciBpcyB0aGUgYWNjZXNzIGNhbGxiYWNrIGRlZmluZWQgYnkgdGhlIGN1c3RvbWVyXG4gICAgLy8gaGVyZSB3ZSBpbmplY3QgdGhlIHJvbGVBY2Nlc3NCdWlsZGVyIGludG8gdGhlIGNhbGxiYWNrIGFuZCBydW4gaXRcbiAgICAvLyB0aGlzIHByb2R1Y2VzIHRoZSBhY2Nlc3MgZGVmaW5pdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JhZ2UgcG9saWNpZXNcbiAgICBjb25zdCBzdG9yYWdlQWNjZXNzRGVmaW5pdGlvbiA9IHRoaXMuc3RvcmFnZUFjY2Vzc0dlbmVyYXRvcihcbiAgICAgIHRoaXMucm9sZUFjY2Vzc0J1aWxkZXIsXG4gICAgKTtcblxuICAgIC8vIHZlcmlmeSB0aGF0IHRoZSBwYXRocyBpbiB0aGUgYWNjZXNzIGRlZmluaXRpb24gYXJlIHZhbGlkXG4gICAgdGhpcy52YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyhPYmplY3Qua2V5cyhzdG9yYWdlQWNjZXNzRGVmaW5pdGlvbikpO1xuXG4gICAgY29uc3Qgc3RvcmFnZU91dHB1dEFjY2Vzc0RlZmluaXRpb246IFJlY29yZDxzdHJpbmcsIFN0b3JhZ2VBY2Nlc3NDb25maWc+ID1cbiAgICAgIHt9O1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBhY2Nlc3MgZGVmaW5pdGlvbiBhbmQgZ3JvdXAgcGVybWlzc2lvbnMgYnkgUmVzb3VyY2VBY2Nlc3NBY2NlcHRvclxuICAgIE9iamVjdC5lbnRyaWVzKHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uKS5mb3JFYWNoKFxuICAgICAgKFtzM1ByZWZpeCwgYWNjZXNzUGVybWlzc2lvbnNdKSA9PiB7XG4gICAgICAgIGNvbnN0IHVuaXF1ZURlZmluaXRpb25JZFNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIG9mIHRoZSBhY2Nlc3MgZGVmaW5pdGlvbnMgZm9yIGEgZ2l2ZW4gcHJlZml4XG4gICAgICAgIGFjY2Vzc1Blcm1pc3Npb25zLmZvckVhY2goKHBlcm1pc3Npb24pID0+IHtcbiAgICAgICAgICBjb25zdCBhY2Nlc3NDb25maWc6IFN0b3JhZ2VBY2Nlc3NDb25maWcgPSB7fTtcbiAgICAgICAgICAvLyByZXBsYWNlIFwicmVhZFwiIHdpdGggXCJnZXRcIiBhbmQgXCJsaXN0XCIgaW4gYWN0aW9uc1xuICAgICAgICAgIGNvbnN0IHJlcGxhY2VSZWFkV2l0aEdldEFuZExpc3QgPSBwZXJtaXNzaW9uLmFjdGlvbnMuZmxhdE1hcChcbiAgICAgICAgICAgIChhY3Rpb24pID0+IChhY3Rpb24gPT09ICdyZWFkJyA/IFsnZ2V0JywgJ2xpc3QnXSA6IFthY3Rpb25dKSxcbiAgICAgICAgICApIGFzIEludGVybmFsU3RvcmFnZUFjdGlvbltdO1xuXG4gICAgICAgICAgLy8gZW5zdXJlIHRoZSBhY3Rpb25zIGxpc3QgaGFzIG5vIGR1cGxpY2F0ZXNcbiAgICAgICAgICBjb25zdCBub0R1cGxpY2F0ZUFjdGlvbnMgPSBBcnJheS5mcm9tKFxuICAgICAgICAgICAgbmV3IFNldChyZXBsYWNlUmVhZFdpdGhHZXRBbmRMaXN0KSxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGFsbCB1bmlxdWVEZWZpbml0aW9uSWRWYWxpZGF0aW9ucyBhbmQgZW5zdXJlIHVuaXF1ZW5lc3Mgd2l0aGluIHRoaXMgcGF0aCBwcmVmaXhcbiAgICAgICAgICBwZXJtaXNzaW9uLnVuaXF1ZURlZmluaXRpb25JZFZhbGlkYXRpb25zLmZvckVhY2goXG4gICAgICAgICAgICAoeyB1bmlxdWVEZWZpbml0aW9uSWQsIHZhbGlkYXRpb25FcnJvck9wdGlvbnMgfSkgPT4ge1xuICAgICAgICAgICAgICBpZiAodW5pcXVlRGVmaW5pdGlvbklkU2V0Lmhhcyh1bmlxdWVEZWZpbml0aW9uSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFtcGxpZnlVc2VyRXJyb3I8U3RvcmFnZUVycm9yPihcbiAgICAgICAgICAgICAgICAgICdJbnZhbGlkU3RvcmFnZUFjY2Vzc0RlZmluaXRpb25FcnJvcicsXG4gICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uRXJyb3JPcHRpb25zLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlRGVmaW5pdGlvbklkU2V0LmFkZCh1bmlxdWVEZWZpbml0aW9uSWQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYWNjZXNzQ29uZmlnW3VuaXF1ZURlZmluaXRpb25JZF0gPSBub0R1cGxpY2F0ZUFjdGlvbnM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gbWFrZSB0aGUgb3duZXIgcGxhY2Vob2xkZXIgc3Vic3RpdHV0aW9uIGluIHRoZSBzMyBwcmVmaXhcbiAgICAgICAgICBjb25zdCBwcmVmaXggPSBwbGFjZWhvbGRlclN1YnN0aXR1dGlvbihcbiAgICAgICAgICAgIHMzUHJlZml4LFxuICAgICAgICAgICAgcGVybWlzc2lvbi5pZFN1YnN0aXR1dGlvbixcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgc3RvcmFnZU91dHB1dEFjY2Vzc0RlZmluaXRpb25bcHJlZml4XSA9IHtcbiAgICAgICAgICAgIC4uLnN0b3JhZ2VPdXRwdXRBY2Nlc3NEZWZpbml0aW9uW3ByZWZpeF0sXG4gICAgICAgICAgICAuLi5hY2Nlc3NDb25maWcsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIC8vIHNldCBhbiBlbnRyeSB0aGF0IG1hcHMgdGhpcyBwZXJtaXNzaW9uIHRvIGVhY2ggcmVzb3VyY2UgYWNjZXB0b3JcbiAgICAgICAgICBwZXJtaXNzaW9uLmdldFJlc291cmNlQWNjZXNzQWNjZXB0b3JzLmZvckVhY2goXG4gICAgICAgICAgICAoZ2V0UmVzb3VyY2VBY2Nlc3NBY2NlcHRvcikgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmFkZEFjY2Vzc0RlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgZ2V0UmVzb3VyY2VBY2Nlc3NBY2NlcHRvcih0aGlzLmdldEluc3RhbmNlUHJvcHMpLFxuICAgICAgICAgICAgICAgIG5vRHVwbGljYXRlQWN0aW9ucyxcbiAgICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICApO1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBhY2Nlc3MgbWFwIGVudHJpZXMgYW5kIGludm9rZSBlYWNoIFJlc291cmNlQWNjZXNzQWNjZXB0b3IgdG8gYWNjZXB0IHRoZSBwZXJtaXNzaW9uc1xuICAgIHRoaXMuYXR0YWNoUG9saWNpZXModGhpcy5zc21FbnZpcm9ubWVudEVudHJpZXMpO1xuXG4gICAgcmV0dXJuIHN0b3JhZ2VPdXRwdXRBY2Nlc3NEZWZpbml0aW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYW4gZW50cnkgdG8gdGhlIGludGVybmFsIGFjY2VwdG9yQWNjZXNzTWFwIGFuZCBwcmVmaXhEZW55TWFwLlxuICAgKiBUaGlzIGVudHJ5IGRlZmluZXMgYSBzZXQgb2YgYWN0aW9ucyBvbiBhIHNpbmdsZSBzMyBwcmVmaXggdGhhdCBzaG91bGQgYmUgYXR0YWNoZWQgdG8gYSBnaXZlbiBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yXG4gICAqL1xuICBwcml2YXRlIGFkZEFjY2Vzc0RlZmluaXRpb24gPSAoXG4gICAgcmVzb3VyY2VBY2Nlc3NBY2NlcHRvcjogUmVzb3VyY2VBY2Nlc3NBY2NlcHRvcixcbiAgICBhY3Rpb25zOiBJbnRlcm5hbFN0b3JhZ2VBY3Rpb25bXSxcbiAgICBzM1ByZWZpeDogU3RvcmFnZVBhdGgsXG4gICkgPT4ge1xuICAgIGNvbnN0IGFjY2VwdG9yVG9rZW4gPSByZXNvdXJjZUFjY2Vzc0FjY2VwdG9yLmlkZW50aWZpZXI7XG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IHNlZW4gdGhpcyB0b2tlbiBiZWZvcmUsIGFkZCBpdCB0byB0aGUgbWFwXG4gICAgaWYgKCF0aGlzLmFjY2VwdG9yQWNjZXNzTWFwLmhhcyhhY2NlcHRvclRva2VuKSkge1xuICAgICAgdGhpcy5hY2NlcHRvckFjY2Vzc01hcC5zZXQoYWNjZXB0b3JUb2tlbiwge1xuICAgICAgICBhY2Nlc3NNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgYWNjZXB0b3I6IHJlc291cmNlQWNjZXNzQWNjZXB0b3IsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYWNjZXNzTWFwID0gdGhpcy5hY2NlcHRvckFjY2Vzc01hcC5nZXQoYWNjZXB0b3JUb2tlbikhLmFjY2Vzc01hcDtcbiAgICAvLyBhZGQgZWFjaCBhY3Rpb24gdG8gdGhlIGFjY2Vzc01hcCBmb3IgdGhpcyBhY2NlcHRvclRva2VuXG4gICAgYWN0aW9ucy5mb3JFYWNoKChhY3Rpb24pID0+IHtcbiAgICAgIGlmICghYWNjZXNzTWFwLmhhcyhhY3Rpb24pKSB7XG4gICAgICAgIC8vIGlmIHdlIGhhdmVuJ3Qgc2VlbiB0aGlzIGFjdGlvbiBmb3IgdGhpcyBhY2NlcHRvclRva2VuIGJlZm9yZSwgYWRkIGl0IHRvIHRoZSBtYXBcbiAgICAgICAgY29uc3QgYWxsb3dTZXQgPSBuZXcgU2V0PFN0b3JhZ2VQYXRoPihbczNQcmVmaXhdKTtcbiAgICAgICAgY29uc3QgZGVueVNldCA9IG5ldyBTZXQ8U3RvcmFnZVBhdGg+KCk7XG4gICAgICAgIGFjY2Vzc01hcC5zZXQoYWN0aW9uLCB7IGFsbG93OiBhbGxvd1NldCwgZGVueTogZGVueVNldCB9KTtcblxuICAgICAgICAvLyB0aGlzIGlzIHdoZXJlIHdlIGNyZWF0ZSB0aGUgcmV2ZXJzZSBtYXBwaW5nIHRoYXQgYWxsb3dzIHVzIHRvIGFkZCBlbnRyaWVzIHRvIHRoZSBkZW55U2V0IGxhdGVyIGJ5IGxvb2tpbmcgdXAgdGhlIHByZWZpeFxuICAgICAgICB0aGlzLnNldFByZWZpeERlbnlNYXBFbnRyeShzM1ByZWZpeCwgYWxsb3dTZXQsIGRlbnlTZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGFkZCB0aGUgcHJlZml4IHRvIHRoZSBleGlzdGluZyBhbGxvdyBzZXRcbiAgICAgICAgY29uc3QgeyBhbGxvdzogYWxsb3dTZXQsIGRlbnk6IGRlbnlTZXQgfSA9IGFjY2Vzc01hcC5nZXQoYWN0aW9uKSE7XG4gICAgICAgIGFsbG93U2V0LmFkZChzM1ByZWZpeCk7XG5cbiAgICAgICAgLy8gYWRkIGFuIGVudHJ5IGluIHRoZSBwcmVmaXhEZW55TWFwIGZvciB0aGUgZXhpc3RpbmcgYWxsb3cgYW5kIGRlbnkgc2V0XG4gICAgICAgIHRoaXMuc2V0UHJlZml4RGVueU1hcEVudHJ5KHMzUHJlZml4LCBhbGxvd1NldCwgZGVueVNldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgYWxsIG9mIHRoZSBhY2Nlc3MgZGVmaW5pdGlvbnMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIG9yY2hlc3RyYXRvcixcbiAgICogZ2VuZXJhdGVzIGEgcG9saWN5IGZvciBlYWNoIGFjY2Vzc01hcCxcbiAgICogYW5kIGF0dGFjaGVzIHRoZSBwb2xpY3kgdG8gdGhlIGNvcnJlc3BvbmRpbmcgUmVzb3VyY2VBY2Nlc3NBY2NlcHRvclxuICAgKlxuICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSBleGlzdGluZyBhY2Nlc3MgZGVmaW5pdGlvbiBzdGF0ZSBpcyBjbGVhcmVkLlxuICAgKiBUaGlzIHByZXZlbnRzIG11bHRpcGxlIGNhbGxzIHRvIHRoaXMgbWV0aG9kIGZyb20gcHJvZHVjaW5nIGR1cGxpY2F0ZSBwb2xpY2llcy5cbiAgICogVGhlIGNsYXNzIGNhbiBjb250aW51ZSB0byBiZSB1c2VkIHRvIGJ1aWxkIHVwIHN0YXRlIGZvciBhIG5ldyBzZXQgb2YgcG9saWNpZXMgaWYgZGVzaXJlZC5cbiAgICogQHBhcmFtIHNzbUVudmlyb25tZW50RW50cmllcyBBZGRpdGlvbmFsIFNTTSBjb250ZXh0IHRoYXQgaXMgcGFzc2VkIHRvIGVhY2ggUmVzb3VyY2VBY2Nlc3NBY2NlcHRvclxuICAgKi9cbiAgcHJpdmF0ZSBhdHRhY2hQb2xpY2llcyA9IChzc21FbnZpcm9ubWVudEVudHJpZXM6IFNzbUVudmlyb25tZW50RW50cnlbXSkgPT4ge1xuICAgIGNvbnN0IGFsbFBhdGhzID0gQXJyYXkuZnJvbSh0aGlzLnByZWZpeERlbnlNYXAua2V5cygpKTtcbiAgICBhbGxQYXRocy5mb3JFYWNoKChzdG9yYWdlUGF0aCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gZmluZFBhcmVudChzdG9yYWdlUGF0aCwgYWxsUGF0aHMpO1xuICAgICAgLy8gZG8gbm90IGFkZCB0byBwcmVmaXggZGVueSBtYXAgaWYgdGhlcmUgaXMgbm8gcGFyZW50IG9yIHRoZSBwYXRoIGlzIGEgc3VicGF0aCB3aXRoIGVudGl0eSBpZFxuICAgICAgaWYgKFxuICAgICAgICAhcGFyZW50IHx8XG4gICAgICAgIHBhcmVudCA9PT0gc3RvcmFnZVBhdGgucmVwbGFjZUFsbChgJHtlbnRpdHlJZFN1YnN0aXR1dGlvbn0vYCwgJycpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaWYgYSBwYXJlbnQgcGF0aCBpcyBkZWZpbmVkLCBpbnZva2UgdGhlIGRlbnlCeURlZmF1bHQgY2FsbGJhY2sgb24gdGhpcyBzdWJwYXRoIGZvciBhbGwgcG9saWNpZXMgdGhhdCBleGlzdCBvbiB0aGUgcGFyZW50IHBhdGhcbiAgICAgIHRoaXMucHJlZml4RGVueU1hcFxuICAgICAgICAuZ2V0KHBhcmVudClcbiAgICAgICAgPy5mb3JFYWNoKChkZW55QnlEZWZhdWx0Q2FsbGJhY2spID0+XG4gICAgICAgICAgZGVueUJ5RGVmYXVsdENhbGxiYWNrKHN0b3JhZ2VQYXRoKSxcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuZm9yRWFjaCgoeyBhY2NlcHRvciwgYWNjZXNzTWFwIH0pID0+IHtcbiAgICAgIC8vIHJlbW92aW5nIHN1YnBhdGhzIGZyb20gdGhlIGFsbG93IHNldCBwcmV2ZW50cyB1bm5lY2Vzc2FyeSBwYXRocyBmcm9tIGJlaW5nIGFkZGVkIHRvIHRoZSBwb2xpY3lcbiAgICAgIC8vIGZvciBleGFtcGxlLCBpZiB0aGVyZSBhcmUgYWxsb3cgcmVhZCBydWxlcyBmb3IgL2Zvby8qIGFuZCAvZm9vL2Jhci8qIHdlIG9ubHkgbmVlZCB0byBhZGQgL2Zvby8qIHRvIHRoZSBwb2xpY3kgYmVjYXVzZSB0aGF0IGluY2x1ZGVzIC9mb28vYmFyLypcbiAgICAgIGFjY2Vzc01hcC5mb3JFYWNoKCh7IGFsbG93IH0pID0+IHtcbiAgICAgICAgcmVtb3ZlU3ViUGF0aHNGcm9tU2V0KGFsbG93KTtcbiAgICAgIH0pO1xuICAgICAgYWNjZXB0b3IuYWNjZXB0UmVzb3VyY2VBY2Nlc3MoXG4gICAgICAgIHRoaXMucG9saWN5RmFjdG9yeS5jcmVhdGVQb2xpY3koYWNjZXNzTWFwKSxcbiAgICAgICAgc3NtRW52aXJvbm1lbnRFbnRyaWVzLFxuICAgICAgKTtcbiAgICB9KTtcbiAgICB0aGlzLmFjY2VwdG9yQWNjZXNzTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5wcmVmaXhEZW55TWFwLmNsZWFyKCk7XG4gIH07XG5cbiAgcHJpdmF0ZSBzZXRQcmVmaXhEZW55TWFwRW50cnkgPSAoXG4gICAgc3RvcmFnZVBhdGg6IFN0b3JhZ2VQYXRoLFxuICAgIGFsbG93UGF0aFNldDogU2V0PFN0b3JhZ2VQYXRoPixcbiAgICBkZW55UGF0aFNldDogU2V0PFN0b3JhZ2VQYXRoPixcbiAgKSA9PiB7XG4gICAgLy8gZnVuY3Rpb24gdGhhdCB3aWxsIGFkZCB0aGUgZGVueVBhdGggdG8gdGhlIGRlbnlQYXRoU2V0IHVubGVzcyB0aGUgYWxsb3dQYXRoU2V0IGV4cGxpY2l0bHkgYWxsb3dzIHRoZSBwYXRoXG4gICAgY29uc3Qgc2V0RGVueUJ5RGVmYXVsdCA9IChkZW55UGF0aDogU3RvcmFnZVBhdGgpID0+IHtcbiAgICAgIGlmICghYWxsb3dQYXRoU2V0LmhhcyhkZW55UGF0aCkpIHtcbiAgICAgICAgZGVueVBhdGhTZXQuYWRkKGRlbnlQYXRoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghdGhpcy5wcmVmaXhEZW55TWFwLmhhcyhzdG9yYWdlUGF0aCkpIHtcbiAgICAgIHRoaXMucHJlZml4RGVueU1hcC5zZXQoc3RvcmFnZVBhdGgsIFtzZXREZW55QnlEZWZhdWx0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJlZml4RGVueU1hcC5nZXQoc3RvcmFnZVBhdGgpPy5wdXNoKHNldERlbnlCeURlZmF1bHQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZhY3RvcnkgaXMgcmVhbGx5IG9ubHkgbmVjZXNzYXJ5IGZvciBhbGxvd2luZyB1cyB0byBtb2NrIHRoZSBTdG9yYWdlQWNjZXNzT3JjaGVzdHJhdG9yIGluIHRlc3RzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdG9yYWdlQWNjZXNzT3JjaGVzdHJhdG9yRmFjdG9yeSB7XG4gIGdldEluc3RhbmNlID0gKFxuICAgIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3I6IFN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IsXG4gICAgZ2V0SW5zdGFuY2VQcm9wczogQ29uc3RydWN0RmFjdG9yeUdldEluc3RhbmNlUHJvcHMsXG4gICAgc3NtRW52aXJvbm1lbnRFbnRyaWVzOiBTc21FbnZpcm9ubWVudEVudHJ5W10sXG4gICAgcG9saWN5RmFjdG9yeTogU3RvcmFnZUFjY2Vzc1BvbGljeUZhY3RvcnksXG4gICkgPT5cbiAgICBuZXcgU3RvcmFnZUFjY2Vzc09yY2hlc3RyYXRvcihcbiAgICAgIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IsXG4gICAgICBnZXRJbnN0YW5jZVByb3BzLFxuICAgICAgc3NtRW52aXJvbm1lbnRFbnRyaWVzLFxuICAgICAgcG9saWN5RmFjdG9yeSxcbiAgICApO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIHRoZSBvd25lciBwbGFjZWhvbGRlciBzdWJzdGl0dXRpb24gaW4gdGhlIHMzIHByZWZpeFxuICovXG5jb25zdCBwbGFjZWhvbGRlclN1YnN0aXR1dGlvbiA9IChcbiAgczNQcmVmaXg6IHN0cmluZyxcbiAgaWRTdWJzdGl0dXRpb246IHN0cmluZyxcbik6IFN0b3JhZ2VQYXRoID0+IHtcbiAgY29uc3QgcHJlZml4ID0gczNQcmVmaXgucmVwbGFjZUFsbChcbiAgICBlbnRpdHlJZFBhdGhUb2tlbixcbiAgICBpZFN1YnN0aXR1dGlvbixcbiAgKSBhcyBTdG9yYWdlUGF0aDtcblxuICAvLyBmb3Igb3duZXIgcGF0aHMgd2hlcmUgcHJlZml4IGVuZHMgd2l0aCAnLyovKicgcmVtb3ZlIHRoZSBsYXN0IHdpbGRjYXJkXG4gIGlmIChwcmVmaXguZW5kc1dpdGgoJy8qLyonKSkge1xuICAgIHJldHVybiBwcmVmaXguc2xpY2UoMCwgLTIpIGFzIFN0b3JhZ2VQYXRoO1xuICB9XG5cbiAgcmV0dXJuIHByZWZpeCBhcyBTdG9yYWdlUGF0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBpbiBwYXRocyB0aGF0IGlzIGEgcHJlZml4IG9mIHBhdGgsIGlmIGFueVxuICogTm90ZSB0aGF0IHRoZXJlIGNhbiBvbmx5IGJlIG9uZSBhdCB0aGlzIHBvaW50IGJlY2F1c2Ugb2YgdXBzdHJlYW0gdmFsaWRhdGlvblxuICovXG5jb25zdCBmaW5kUGFyZW50ID0gKHBhdGg6IHN0cmluZywgcGF0aHM6IHN0cmluZ1tdKSA9PlxuICBwYXRocy5maW5kKChwKSA9PiBwYXRoICE9PSBwICYmIHBhdGguc3RhcnRzV2l0aChwLnJlcGxhY2VBbGwoJyonLCAnJykpKSBhc1xuICAgIHwgU3RvcmFnZVBhdGhcbiAgICB8IHVuZGVmaW5lZDtcblxuY29uc3QgcmVtb3ZlU3ViUGF0aHNGcm9tU2V0ID0gKHBhdGhzOiBTZXQ8U3RvcmFnZVBhdGg+KSA9PiB7XG4gIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICBpZiAoZmluZFBhcmVudChwYXRoLCBBcnJheS5mcm9tKHBhdGhzKSkpIHtcbiAgICAgIHBhdGhzLmRlbGV0ZShwYXRoKTtcbiAgICB9XG4gIH0pO1xufTtcbiJdfQ==