import fs from 'fs';
import { staticEnvironmentVariables } from './static_env_types.js';
import path from 'path';
import { EOL } from 'os';
/**
 * Generates a typed process.env shim for environment variables
 */
export class FunctionEnvironmentTypeGenerator {
    functionName;
    header = '// This file is auto-generated by Amplify. Edits will be overwritten.';
    // The variable gets updated when the fully typed file is updated.
    envAssignment = 'export const env = process.env';
    typeDefFilePath;
    indentation = '  ';
    /**
     * Initialize typed process.env shim file name and location
     */
    constructor(functionName) {
        this.functionName = functionName;
        this.typeDefFilePath = `${process.cwd()}/.amplify/generated/env/${this.functionName}.ts`;
    }
    /**
     * Generate a typed process.env shim
     */
    generateTypedProcessEnvShim(amplifyBackendEnvVars) {
        const lambdaEnvVarTypeName = 'LambdaProvidedEnvVars';
        const amplifyBackendEnvVarTypeName = 'AmplifyBackendEnvVars';
        const declarations = [];
        // Add Lambda runtime environment variables to the typed shim
        declarations.push(`/** Lambda runtime environment variables, see https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime */`);
        declarations.push(`type ${lambdaEnvVarTypeName} = {`);
        for (const key in staticEnvironmentVariables) {
            const comment = `${this.indentation}/** ${staticEnvironmentVariables[key]} */`;
            const declaration = `${this.indentation}${key}: string;`;
            declarations.push(comment + EOL + declaration + EOL);
        }
        declarations.push(`};${EOL}`);
        /**
         * Add Amplify backend environment variables to the typed shim which can be either of the following:
         * 1. Defined by the customer passing env vars to the environment parameter for defineFunction
         * 2. Defined by resource access mechanisms
         */
        declarations.push(`/** Amplify backend environment variables available at runtime, this includes environment variables defined in \`defineFunction\` and by cross resource mechanisms */`);
        declarations.push(`type ${amplifyBackendEnvVarTypeName} = {`);
        // Use a Set to remove duplicates
        const uniqueEnvVars = new Set(amplifyBackendEnvVars);
        uniqueEnvVars.forEach((envName) => {
            const declaration = `${this.indentation}${envName}: string;`;
            declarations.push(declaration);
        });
        declarations.push(`};${EOL}`);
        const content = `${this.header}${EOL}${this.envAssignment} as unknown as ${lambdaEnvVarTypeName} & ${amplifyBackendEnvVarTypeName};${EOL}${EOL}${declarations.join(EOL)}`;
        this.writeShimFile(content);
    }
    /**
     * Generate an any-typed process.env shim if doesn't exist
     */
    generateProcessEnvShim = () => {
        // Create an "any" typed variable while creating the initial file to keep TSC happy
        // in case the synth fails and doesn't generate the typed shim.
        // We run TSC regardless after the synth to show more relevant TS errors and this prevents showing env related type errors.
        const content = `${this.header}${EOL}${this.envAssignment} as any;`;
        this.writeShimFile(content);
    };
    writeShimFile = (content) => {
        const typeDefFileDirname = path.dirname(this.typeDefFilePath);
        if (!fs.existsSync(typeDefFileDirname)) {
            fs.mkdirSync(typeDefFileDirname, { recursive: true });
        }
        fs.writeFileSync(this.typeDefFilePath, content);
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnVuY3Rpb25fZW52X3R5cGVfZ2VuZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2Z1bmN0aW9uX2Vudl90eXBlX2dlbmVyYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDcEIsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDbkUsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBQ3hCLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFFekI7O0dBRUc7QUFDSCxNQUFNLE9BQU8sZ0NBQWdDO0lBY2Q7SUFiWixNQUFNLEdBQ3JCLHVFQUF1RSxDQUFDO0lBRTFFLGtFQUFrRTtJQUNqRCxhQUFhLEdBQUcsZ0NBQWdDLENBQUM7SUFFMUQsZUFBZSxDQUFTO0lBRXhCLFdBQVcsR0FBVyxJQUFJLENBQUM7SUFFbkM7O09BRUc7SUFDSCxZQUE2QixZQUFvQjtRQUFwQixpQkFBWSxHQUFaLFlBQVksQ0FBUTtRQUMvQyxJQUFJLENBQUMsZUFBZSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRSwyQkFDckMsSUFBSSxDQUFDLFlBQ1AsS0FBSyxDQUFDO0lBQ1IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsMkJBQTJCLENBQUMscUJBQStCO1FBQ3pELE1BQU0sb0JBQW9CLEdBQUcsdUJBQXVCLENBQUM7UUFDckQsTUFBTSw0QkFBNEIsR0FBRyx1QkFBdUIsQ0FBQztRQUU3RCxNQUFNLFlBQVksR0FBRyxFQUFFLENBQUM7UUFFeEIsNkRBQTZEO1FBQzdELFlBQVksQ0FBQyxJQUFJLENBQ2Ysd0pBQXdKLENBQ3pKLENBQUM7UUFDRixZQUFZLENBQUMsSUFBSSxDQUFDLFFBQVEsb0JBQW9CLE1BQU0sQ0FBQyxDQUFDO1FBQ3RELEtBQUssTUFBTSxHQUFHLElBQUksMEJBQTBCLEVBQUU7WUFDNUMsTUFBTSxPQUFPLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxPQUFPLDBCQUEwQixDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7WUFDL0UsTUFBTSxXQUFXLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxHQUFHLEdBQUcsV0FBVyxDQUFDO1lBRXpELFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLEdBQUcsR0FBRyxXQUFXLEdBQUcsR0FBRyxDQUFDLENBQUM7U0FDdEQ7UUFDRCxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsQ0FBQztRQUU5Qjs7OztXQUlHO1FBQ0gsWUFBWSxDQUFDLElBQUksQ0FDZix1S0FBdUssQ0FDeEssQ0FBQztRQUNGLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSw0QkFBNEIsTUFBTSxDQUFDLENBQUM7UUFFOUQsaUNBQWlDO1FBQ2pDLE1BQU0sYUFBYSxHQUFHLElBQUksR0FBRyxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFFckQsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sRUFBRSxFQUFFO1lBQ2hDLE1BQU0sV0FBVyxHQUFHLEdBQUcsSUFBSSxDQUFDLFdBQVcsR0FBRyxPQUFPLFdBQVcsQ0FBQztZQUU3RCxZQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2pDLENBQUMsQ0FBQyxDQUFDO1FBQ0gsWUFBWSxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFFOUIsTUFBTSxPQUFPLEdBQUcsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLEdBQUcsR0FDbEMsSUFBSSxDQUFDLGFBQ1Asa0JBQWtCLG9CQUFvQixNQUFNLDRCQUE0QixJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FDdkcsR0FBRyxDQUNKLEVBQUUsQ0FBQztRQUVKLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsc0JBQXNCLEdBQUcsR0FBRyxFQUFFO1FBQzVCLG1GQUFtRjtRQUNuRiwrREFBK0Q7UUFDL0QsMkhBQTJIO1FBQzNILE1BQU0sT0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLGFBQWEsVUFBVSxDQUFDO1FBQ3BFLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDOUIsQ0FBQyxDQUFDO0lBRU0sYUFBYSxHQUFHLENBQUMsT0FBZSxFQUFFLEVBQUU7UUFDMUMsTUFBTSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUU5RCxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFO1lBQ3RDLEVBQUUsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztTQUN2RDtRQUVELEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUNsRCxDQUFDLENBQUM7Q0FDSCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgeyBzdGF0aWNFbnZpcm9ubWVudFZhcmlhYmxlcyB9IGZyb20gJy4vc3RhdGljX2Vudl90eXBlcy5qcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IEVPTCB9IGZyb20gJ29zJztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB0eXBlZCBwcm9jZXNzLmVudiBzaGltIGZvciBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uRW52aXJvbm1lbnRUeXBlR2VuZXJhdG9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBoZWFkZXIgPVxuICAgICcvLyBUaGlzIGZpbGUgaXMgYXV0by1nZW5lcmF0ZWQgYnkgQW1wbGlmeS4gRWRpdHMgd2lsbCBiZSBvdmVyd3JpdHRlbi4nO1xuXG4gIC8vIFRoZSB2YXJpYWJsZSBnZXRzIHVwZGF0ZWQgd2hlbiB0aGUgZnVsbHkgdHlwZWQgZmlsZSBpcyB1cGRhdGVkLlxuICBwcml2YXRlIHJlYWRvbmx5IGVudkFzc2lnbm1lbnQgPSAnZXhwb3J0IGNvbnN0IGVudiA9IHByb2Nlc3MuZW52JztcblxuICBwcml2YXRlIHR5cGVEZWZGaWxlUGF0aDogc3RyaW5nO1xuXG4gIHByaXZhdGUgaW5kZW50YXRpb246IHN0cmluZyA9ICcgICc7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdHlwZWQgcHJvY2Vzcy5lbnYgc2hpbSBmaWxlIG5hbWUgYW5kIGxvY2F0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGZ1bmN0aW9uTmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy50eXBlRGVmRmlsZVBhdGggPSBgJHtwcm9jZXNzLmN3ZCgpfS8uYW1wbGlmeS9nZW5lcmF0ZWQvZW52LyR7XG4gICAgICB0aGlzLmZ1bmN0aW9uTmFtZVxuICAgIH0udHNgO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHlwZWQgcHJvY2Vzcy5lbnYgc2hpbVxuICAgKi9cbiAgZ2VuZXJhdGVUeXBlZFByb2Nlc3NFbnZTaGltKGFtcGxpZnlCYWNrZW5kRW52VmFyczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBsYW1iZGFFbnZWYXJUeXBlTmFtZSA9ICdMYW1iZGFQcm92aWRlZEVudlZhcnMnO1xuICAgIGNvbnN0IGFtcGxpZnlCYWNrZW5kRW52VmFyVHlwZU5hbWUgPSAnQW1wbGlmeUJhY2tlbmRFbnZWYXJzJztcblxuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IFtdO1xuXG4gICAgLy8gQWRkIExhbWJkYSBydW50aW1lIGVudmlyb25tZW50IHZhcmlhYmxlcyB0byB0aGUgdHlwZWQgc2hpbVxuICAgIGRlY2xhcmF0aW9ucy5wdXNoKFxuICAgICAgYC8qKiBMYW1iZGEgcnVudGltZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vbGFtYmRhL2xhdGVzdC9kZy9jb25maWd1cmF0aW9uLWVudnZhcnMuaHRtbCNjb25maWd1cmF0aW9uLWVudnZhcnMtcnVudGltZSAqL2AsXG4gICAgKTtcbiAgICBkZWNsYXJhdGlvbnMucHVzaChgdHlwZSAke2xhbWJkYUVudlZhclR5cGVOYW1lfSA9IHtgKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdGF0aWNFbnZpcm9ubWVudFZhcmlhYmxlcykge1xuICAgICAgY29uc3QgY29tbWVudCA9IGAke3RoaXMuaW5kZW50YXRpb259LyoqICR7c3RhdGljRW52aXJvbm1lbnRWYXJpYWJsZXNba2V5XX0gKi9gO1xuICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSBgJHt0aGlzLmluZGVudGF0aW9ufSR7a2V5fTogc3RyaW5nO2A7XG5cbiAgICAgIGRlY2xhcmF0aW9ucy5wdXNoKGNvbW1lbnQgKyBFT0wgKyBkZWNsYXJhdGlvbiArIEVPTCk7XG4gICAgfVxuICAgIGRlY2xhcmF0aW9ucy5wdXNoKGB9OyR7RU9MfWApO1xuXG4gICAgLyoqXG4gICAgICogQWRkIEFtcGxpZnkgYmFja2VuZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gdGhlIHR5cGVkIHNoaW0gd2hpY2ggY2FuIGJlIGVpdGhlciBvZiB0aGUgZm9sbG93aW5nOlxuICAgICAqIDEuIERlZmluZWQgYnkgdGhlIGN1c3RvbWVyIHBhc3NpbmcgZW52IHZhcnMgdG8gdGhlIGVudmlyb25tZW50IHBhcmFtZXRlciBmb3IgZGVmaW5lRnVuY3Rpb25cbiAgICAgKiAyLiBEZWZpbmVkIGJ5IHJlc291cmNlIGFjY2VzcyBtZWNoYW5pc21zXG4gICAgICovXG4gICAgZGVjbGFyYXRpb25zLnB1c2goXG4gICAgICBgLyoqIEFtcGxpZnkgYmFja2VuZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXZhaWxhYmxlIGF0IHJ1bnRpbWUsIHRoaXMgaW5jbHVkZXMgZW52aXJvbm1lbnQgdmFyaWFibGVzIGRlZmluZWQgaW4gXFxgZGVmaW5lRnVuY3Rpb25cXGAgYW5kIGJ5IGNyb3NzIHJlc291cmNlIG1lY2hhbmlzbXMgKi9gLFxuICAgICk7XG4gICAgZGVjbGFyYXRpb25zLnB1c2goYHR5cGUgJHthbXBsaWZ5QmFja2VuZEVudlZhclR5cGVOYW1lfSA9IHtgKTtcblxuICAgIC8vIFVzZSBhIFNldCB0byByZW1vdmUgZHVwbGljYXRlc1xuICAgIGNvbnN0IHVuaXF1ZUVudlZhcnMgPSBuZXcgU2V0KGFtcGxpZnlCYWNrZW5kRW52VmFycyk7XG5cbiAgICB1bmlxdWVFbnZWYXJzLmZvckVhY2goKGVudk5hbWUpID0+IHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gYCR7dGhpcy5pbmRlbnRhdGlvbn0ke2Vudk5hbWV9OiBzdHJpbmc7YDtcblxuICAgICAgZGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRpb24pO1xuICAgIH0pO1xuICAgIGRlY2xhcmF0aW9ucy5wdXNoKGB9OyR7RU9MfWApO1xuXG4gICAgY29uc3QgY29udGVudCA9IGAke3RoaXMuaGVhZGVyfSR7RU9MfSR7XG4gICAgICB0aGlzLmVudkFzc2lnbm1lbnRcbiAgICB9IGFzIHVua25vd24gYXMgJHtsYW1iZGFFbnZWYXJUeXBlTmFtZX0gJiAke2FtcGxpZnlCYWNrZW5kRW52VmFyVHlwZU5hbWV9OyR7RU9MfSR7RU9MfSR7ZGVjbGFyYXRpb25zLmpvaW4oXG4gICAgICBFT0wsXG4gICAgKX1gO1xuXG4gICAgdGhpcy53cml0ZVNoaW1GaWxlKGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGFueS10eXBlZCBwcm9jZXNzLmVudiBzaGltIGlmIGRvZXNuJ3QgZXhpc3RcbiAgICovXG4gIGdlbmVyYXRlUHJvY2Vzc0VudlNoaW0gPSAoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGFuIFwiYW55XCIgdHlwZWQgdmFyaWFibGUgd2hpbGUgY3JlYXRpbmcgdGhlIGluaXRpYWwgZmlsZSB0byBrZWVwIFRTQyBoYXBweVxuICAgIC8vIGluIGNhc2UgdGhlIHN5bnRoIGZhaWxzIGFuZCBkb2Vzbid0IGdlbmVyYXRlIHRoZSB0eXBlZCBzaGltLlxuICAgIC8vIFdlIHJ1biBUU0MgcmVnYXJkbGVzcyBhZnRlciB0aGUgc3ludGggdG8gc2hvdyBtb3JlIHJlbGV2YW50IFRTIGVycm9ycyBhbmQgdGhpcyBwcmV2ZW50cyBzaG93aW5nIGVudiByZWxhdGVkIHR5cGUgZXJyb3JzLlxuICAgIGNvbnN0IGNvbnRlbnQgPSBgJHt0aGlzLmhlYWRlcn0ke0VPTH0ke3RoaXMuZW52QXNzaWdubWVudH0gYXMgYW55O2A7XG4gICAgdGhpcy53cml0ZVNoaW1GaWxlKGNvbnRlbnQpO1xuICB9O1xuXG4gIHByaXZhdGUgd3JpdGVTaGltRmlsZSA9IChjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB0eXBlRGVmRmlsZURpcm5hbWUgPSBwYXRoLmRpcm5hbWUodGhpcy50eXBlRGVmRmlsZVBhdGgpO1xuXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHR5cGVEZWZGaWxlRGlybmFtZSkpIHtcbiAgICAgIGZzLm1rZGlyU3luYyh0eXBlRGVmRmlsZURpcm5hbWUsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGZzLndyaXRlRmlsZVN5bmModGhpcy50eXBlRGVmRmlsZVBhdGgsIGNvbnRlbnQpO1xuICB9O1xufVxuIl19